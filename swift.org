#+TITLE: Swift
#+AUTHOR: Elliot Penson

* Language Basics
  
  Information is taken from Apple's /The Swift Programming Language/ document.
  
** Constants and Variables
   
   #+BEGIN_SRC swift
     let maximumLoginAttempts = 10
     var currentLoginAttempt = 0
   #+END_SRC
   
   The keyword *let* declares a constant, *var* a variable. Swift allows
   multiple declarations on a single line:
   
   #+BEGIN_SRC swift
     var x = 0.0, y = 0.0, z = 0.0
   #+END_SRC
   
   *Type declarations*
   
   #+BEGIN_SRC swift
     var someString : String
     var red, green, blue: Double
   #+END_SRC
   
   Names can contain Unicode characters! No whitespace, mathematical symbols,
   arrows, private-use (or invalid) Unicode code points, or line- and box-
   drawing characters. Nor can they /begin/ with a number. You cannot redclare
   constants or variables (Yay!).
   
   *println* is a global function that prints a value followed by a line break.
   
   #+BEGIN_SRC swift
     println("this is a test of our virtual communications")
   #+END_SRC
   
   *String interpolation* allows the combination of variables/constants and
   strings.
   
   #+BEGIN_SRC swift
     println("The current value of someString is \(somestring)")
   #+END_SRC
   
** Comments
   
   Single-line and multiline comments are supported.
   
   #+BEGIN_SRC swift
     // this is a comment
     /* this is also a comment,
     but written over multiple lines */
   #+END_SRC
   
   Nested multiline comments are allowed.
   
** Semicolons
   
   Semicolons are optional. They /are/ required however, if you want to write
   multiple separate statements on a single line.
   
** Numbers
   
*** Integers
    
    Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.
    These integers follow a naming convention similar to C, in that a 8-bit
    unsigned integer is of type *UInt8*, and a 32-bit signed integer is of type
    *Int32*. Unless you need to work with a specific size of integer, always use
    *Int* and *UInt* for integer values in your code for consistency and
    interoperability. *Int* is generally preferred when either type would be
    appropriate.
    
*** Floating-Point Numbers
    
    Swift provides two signed floating-point number types:
    
    - *Double* represents a 64-bit floating-point number
    - *Float* represents a 32-bit floating-point number
      
    *Double* is generally preferred when either type would be appropriate.
    
** Type Safety and Type Inference
   
   Swift is a *type safe* language and performs *type checks* when compiling.
   When a type isn't specified, Swift used *type inference*. When declaring a
   constant or variable with an initial value, the type is inferred from the
   *literal*.
   
** Booleans
   
   Swift has a Boolean type, called *Bool*, and two Boolean constant values:
   *true* and *false*.
   
** Optionals
   
   You use *optionals* in situations where a value may be absent. An optional
   says, "there /is/ a value, and it equals /x/" or "there /isn't/ a value at
   all". An optional *Int* is written as *Int?*, not *Int*. You set an
   optional variable to a valueless state by assigning it the special value
   nil:
   
   #+BEGIN_SRC swift
     var serverResponseCode: Int? = 404
     serverResponseCode = nil
   #+END_SRC
   
   If you define an optional variable without providing a default value, the
   variable is automatically set to nil for you.
   
   You can use an if statement to find out whether an optional contains a value
   by comparing the optional against nil.
   
   #+BEGIN_SRC swift
     let possibleNumber = "123"
     let convertedNumber = possibleNumber.toInt()
     if convertedNumber != nil {
         println("convertedNumber contains some integer value.")
     }
   #+END_SRC
   
   Once you're sure that the optional /does/ contain a value, you can access
   its underlying value by adding an exclamation mark (!) to the end of the
   optional's name (called *forced unwrapping*).
   
   You use *optional binding* to find out whether an optional contains
   a value, and if so, to make that value available as a temporary
   constant or variable.
   
   #+BEGIN_SRC swift
     if let actualNumber = possibleNumber.toInt() {
         println("\'\(possibleNumber)\' has an integer value of \(actualNumber)")
     } else {
         println("\'\(possibleNumber)\' could not be converted to an integer")
     }
   #+END_SRC
   
   Note that there's no need to use the ! suffix to access the value.
   
   You write an *implicitly unwrapped optional* by placing an
   exclamation mark (String!) rather than a question mark (String?)
   after the type that you went to make optional. You can think of an
   implicitly unwrapped optional as giving permission for the optional
   to be unwrapped automatically whenever it is used. You can still
   check if an implicitly unwrapped optional is nil and unwrap it in
   an optional binding. Note: do not use an implicitly unwrapped
   optional when there is a possibility of a variable becoming nil at
   a later point.
   
** Assertions
   
   You write an assertion by calling the global *assert* function. You
   pass the *assert* function an expression that evaluates to *true*
   or *false* and a message that should be displayed if the result of
   the condition is false:
   
   #+BEGIN_SRC swift
     let age = -3
     assert(age >= 0, "A person's age cannot be less than zero")
   #+END_SRC
   
   Note that the assertion message can be omitted if desired:
   
   #+BEGIN_SRC swift
     assert(age >= 0)
   #+END_SRC
   
* Basic Operators
  
** Assignment Operator
   
   The /assignment operator/ (a = b) initializes or update the value of
   a with the value of b. This operator also operates on tuples:
   
   #+BEGIN_SRC swift
     let (x, y) = (1, 2)
   #+END_SRC
   
   The assignment operator (=) does not return a value, to prevent it
   from being mistakenly used when the equal to operator (==) is
   intended.
   
** Arithmetic Operators
   
   Arithmetic operators (+, -, *, /, %, and so forth) detect and
   disallow value overflow.
   
   The addition perator is also supported for /String/ concatenation:
   
   #+BEGIN_SRC swift
    "hello, " + "world" // equals "hello, world"
   #+END_SRC
   
   Swift lets you perform remainder (%) calculations on floating-point
   numbers. Also note that the sign is ignored when using % (that's
   also why it's called /remainder/ instead of /modulo/).
   
   Like C, Swift provides an /increment operator/ (++) and a /decrement
   operator (--) as a shortcut to increase or decrease the value of a
   numeric variable by 1. The ++ and -- symbols can be used as prefix
   operators or as postfix operators:
   
  - If the operator is written /before/ the variable, it increments
    the variable /before/ returning its value.
  - If the operator is written /after/ the variable, it increments the
    variable /after/ returning its value.
    
  Unless you need the specific behavior of i++, it is recommended that
  you use ++i and --i in all cases.
  
  The sign of a numeric value can be toggled using a prefixed -, known
  as the /unary minus operator/:
  
  #+BEGIN_SRC swift
    let three = 3
    let minusThree = -three      // equals -3
    let plusThree = -minusThree  // equals 3
  #+END_SRC
  
** Compound Assignment Operators
   
   Like C, Swift provides /compound assignment operators/ that combine
   assignment (=) with another operation. For example the /addition
   assignment operator (+=).
   
   #+BEGIN_SRC swift
    var a = 1
    a += 2
    // a is now equal to 3
   #+END_SRC
   
** Comparison Operators
   
   Swift supports all standard C /comparison operators/ (==, !=, >, <,
   <=, <=). Also note that Swift provides two /identity operators/ (===
   and !==), which you use to test whether two object references both
   refer to the same object instance.
   
** Range Operators
   
*** Closed Range Operator
    
    The /closed range operator/ (a...b) defines a range that runs from
    a to b, and includes the values a and b. The value of a must not
    be greater than b.
    
    #+BEGIN_SRC swift
      for index in 1...5 {
          println("\(index) times 5 is \(index * 5)")
      }
      // 1 times 5 is 5
      // 2 times 5 is 10
      // 3 times 5 is 15
      // 4 times 5 is 20
      // 5 times 5 is 25

    #+END_SRC
    
*** Half-Open Range Operator
    
    The /half-open range operator/ (a..<b) defines a range that runs
    from a to b, but does not include b (particularly useful for
    zero-based lists). If the value of a is equal to b, then the
    resulting range will be empty.
    
** Logical Operators
   
   Swift supports the three standard logical operators found in
   C-based languages (!, &&, and ||). The AND and OR operators use
   short-circuit evaluation to consider its expressions. The Swift
   logical operators && and || are left-associative, meaning that
   compound expressions with multiple logical operators evaluate the
   leftmost subexpression first.

* Strings and Characters

** String Literals
   
   #+BEGIN_SRC swift
     let someString = "Some string literal value"
   #+END_SRC
   
   Note that Swift infers a type of *String* for the someString
   constant.

** Initializing an Empty String

   To create an empty String value as the starting point for building
   a longer string, either assign an empty string literal to a
   variable, or initialize a new String instance with initializer
   syntax:

   #+BEGIN_SRC swift
     var emptyString = ""              // empty string literal
     var anotherEmptyString = String() // initializer syntax
   #+END_SRC

   Find out whether a String value is empty by checking its Boolean
   isEmpty property:

   #+BEGIN_SRC swift
     if emptyString.isEmpty {
         println("Nothing to see here")
     }
   #+END_SRC

** String Mutability

   You indivate whether a particular String can be modified (or
   /mutated/) by assigning it to a variable (in which ase it can be
   modified), or to a constant (in which case it cannot be modified).

** Strings Are Value Types

   Swift's String type is a /value type/. If you create a new String
   value, that String value is /copied/ when it is passed to a
   function or method, or when it is assigned to a constant or
   variable.

** Working with Characters

   Swift's String type represents a collection of *Character* values
   in a specific order. You can access the individual Character values
   in a string by iterating over that string with a for-in loop:

   #+BEGIN_SRC swift
     for character in "Dog!" {
         println(character)
     }
   #+END_SRC
   
   Alternativly, create a stand-alone Character constant or variable
   from a single-character string literal by providing a /Character/
   type annotation:
   
   #+BEGIN_SRC swift
     let exclamationMark: Character = "!"
   #+END_SRC

   String values can be constructed by passing an array of Character
   values as an argument to its initializer:

   #+BEGIN_SRC swift
     let catCharacters: [Character] = ["C", "a", "t", "!"]
     let catString = String(catCharacters)
   #+END_SRC

** Concatenating String and Characters

   The addition operator (+) can be used to concatenate strings. The
   addition assignment operator (+=) can be used to append a String
   value to an existing String variable. You can append a Character
   value to a String variable with the String type's *append()*
   method:

   #+BEGIN_SRC swift
     var welcome = "hello there"
     let exclamationMark: Character = "!"
     welcome.append(exclamationMark)
   #+END_SRC

** String Interpolation

   #+BEGIN_SRC swift
     let multiplier = 3
     let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
     // message is "3 times 2.5 is 7.5"
   #+END_SRC

   Note: the expressions you write inside parentheses within an
   interpolated string cannot contain an unescaped double quote (") or
   backslash(\), and cannot contain a carriage return or line feed.

** Counting Characters

   To retrieve a count of the *Character* values in a string, call the
   global *count(_:)* function and pass in a string as the function's
   sole parameter:
   
   #+BEGIN_SRC swift
     let animals = "Koala, Snail, Penguin"
     println("animals has \(count(animals)) characters")
     // prints "animals has 21 characters"
   #+END_SRC

** Accessing and Modifying a String

*** String Indexes

    Each *String* value has an associated /index type/,
    *String.Index*, which corresponds to the positions of each
    *Character* it contains. Different characters can require
    different amounts of memory to store; Swift strings cannot be
    indexed by integer values.

    Use the *startIndex* property to access the position of the first
    *Character* of a *String*, and the *endIndex* property to access
    the position of the last.

    You can use subscript syntax to access the Character at a
    particular String index:

    #+BEGIN_SRC swift
      let greeting = "Guten Tag"
      greeting[greeting.startIndex] // G
    #+END_SRC
    
    A *String.Index* value can access its immediately preceding index
    by calling the *predecessor()* method, and its immediately
    succeeding index by calling the *successor()* method. Any index in
    a String can be accessed from any other index by chaining these
    methods together, or by using the global *advance(start:n:)*
    function.

    #+BEGIN_SRC swift
      greeting[greeting.startIndex.successor()]   // u
      greeting[greeting.startIndex.predecessor()] // g
      let index = advance(greeting.startIndex, 7)
      greeting[index] // a
    #+END_SRC
    
    Use the global function *indicies(_:)* to create a *Range* of all
    of the indexes used to access individual characters in a string.

    #+BEGIN_SRC swift
      for index in indices(greeting) {
          print("\(greeting[index]) ")
      }
      println("\n")
      // prints "G u t e n  T a g"
    #+END_SRC

*** Inserting and Removing

    To insert a character into a string at a specified index, use the
    *insert(:atIndex:)* method.

    #+BEGIN_SRC swift
      var welcome = "hello"
      welcome.insert("!", atIndex: welcome.endIndex)
      println(welcome)
      // prints "hello!"
    #+END_SRC

    To insert another string at a specified index, use the
    *splice(_:atIndex:)* method.

    #+BEGIN_SRC swift
      welcome.splice(" there", atIndex: welcome.endIndex.predecessor())
      println(welcome)
      // prints "hello there!"
    #+END_SRC

    To remove a character from a string at a specified index, use the
    *removeAtIndex(_:)* method.

    #+BEGIN_SRC swift
      welcome.removeAtIndex(welcome.endIndex.predecessor()) // !
      println(welcome) // prints "hello there"
    #+END_SRC

    To remove a substringat a specified range, use the removeRange(_:)
    method:

    #+BEGIN_SRC swift
      let range = advance(welcome.endIndex, -6)..<welcome.endIndex
      welcome.removeRange(range)
      println(welcome)
      // prints "hello"
    #+END_SRC

** Comparing Strings

   String and character equality is chacked with the "equal to"
   operator (==) and the "not equal to" operator (!=). To check
   whether a string has a particular string prefix or suffix, call the
   string's *hasPrefix(\_:)* and *hasSuffix(\_:)* methods, both of
   which take a single argument of type String and return a Boolean
   value.

   #+BEGIN_SRC swift
     let play = "Act 1 Scene 1: Verona, A public place"
     play.hasPrefix("Act 1 ") // evaluates to true
   #+END_SRC

** Strings and Arrays

   A String can be converted to an Array<Character> like this:

   #+BEGIN_SRC swift
     let myArrayOfCharacters = Array(myString)   
   #+END_SRC  
