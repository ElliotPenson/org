#+TITLE: Swift
#+AUTHOR: Elliot Penson

* Language Basics
  
  Information is taken from Apple's /The Swift Programming Language/ document.
  
** Constants and Variables
   
   #+BEGIN_SRC swift
     let maximumLoginAttempts = 10
     var currentLoginAttempt = 0
   #+END_SRC
   
   The keyword *let* declares a constant, *var* a variable. Swift allows
   multiple declarations on a single line:
   
   #+BEGIN_SRC swift
     var x = 0.0, y = 0.0, z = 0.0
   #+END_SRC
   
   *Type declarations*
   
   #+BEGIN_SRC swift
     var someString : String
     var red, green, blue: Double
   #+END_SRC
   
   Names can contain Unicode characters! No whitespace, mathematical symbols,
   arrows, private-use (or invalid) Unicode code points, or line- and box-
   drawing characters. Nor can they /begin/ with a number. You cannot redclare
   constants or variables (Yay!).
   
   *println* is a global function that prints a value followed by a line break.
   
   #+BEGIN_SRC swift
     println("this is a test of our virtual communications")
   #+END_SRC
   
   *String interpolation* allows the combination of variables/constants and
   strings.
   
   #+BEGIN_SRC swift
     println("The current value of someString is \(somestring)")
   #+END_SRC
   
** Comments
   
   Single-line and multiline comments are supported.
   
   #+BEGIN_SRC swift
     // this is a comment
     /* this is also a comment,
     but written over multiple lines */
   #+END_SRC
   
   Nested multiline comments are allowed.
   
** Semicolons
   
   Semicolons are optional. They /are/ required however, if you want to write
   multiple separate statements on a single line.
   
** Numbers
   
*** Integers
    
    Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.
    These integers follow a naming convention similar to C, in that a 8-bit
    unsigned integer is of type *UInt8*, and a 32-bit signed integer is of type
    *Int32*. Unless you need to work with a specific size of integer, always use
    *Int* and *UInt* for integer values in your code for consistency and
    interoperability. *Int* is generally preferred when either type would be
    appropriate.
    
*** Floating-Point Numbers
    
    Swift provides two signed floating-point number types:
    
    - *Double* represents a 64-bit floating-point number
    - *Float* represents a 32-bit floating-point number
      
    *Double* is generally preferred when either type would be appropriate.
    
** Type Safety and Type Inference
   
   Swift is a *type safe* language and performs *type checks* when compiling.
   When a type isn't specified, Swift used *type inference*. When declaring a
   constant or variable with an initial value, the type is inferred from the
   *literal*.
   
** Booleans
   
   Swift has a Boolean type, called *Bool*, and two Boolean constant values:
   *true* and *false*.
   
** Optionals
   
   You use *optionals* in situations where a value may be absent. An optional
   says, "there /is/ a value, and it equals /x/" or "there /isn't/ a value at
   all". An optional *Int* is written as *Int?*, not *Int*. You set an
   optional variable to a valueless state by assigning it the special value
   nil:
   
   #+BEGIN_SRC swift
     var serverResponseCode: Int? = 404
     serverResponseCode = nil
   #+END_SRC
   
   If you define an optional variable without providing a default value, the
   variable is automatically set to nil for you.
   
   You can use an if statement to find out whether an optional contains a value
   by comparing the optional against nil.
   
   #+BEGIN_SRC swift
     let possibleNumber = "123"
     let convertedNumber = possibleNumber.toInt()
     if convertedNumber != nil {
         println("convertedNumber contains some integer value.")
     }
   #+END_SRC
   
   Once you're sure that the optional /does/ contain a value, you can access
   its underlying value by adding an exclamation mark (!) to the end of the
   optional's name (called *forced unwrapping*).
   
   You use *optional binding* to find out whether an optional contains
   a value, and if so, to make that value available as a temporary
   constant or variable.
   
   #+BEGIN_SRC swift
     if let actualNumber = possibleNumber.toInt() {
         println("\'\(possibleNumber)\' has an integer value of \(actualNumber)")
     } else {
         println("\'\(possibleNumber)\' could not be converted to an integer")
     }
   #+END_SRC
   
   Note that there's no need to use the ! suffix to access the value.
   
   You write an *implicitly unwrapped optional* by placing an
   exclamation mark (String!) rather than a question mark (String?)
   after the type that you went to make optional. You can think of an
   implicitly unwrapped optional as giving permission for the optional
   to be unwrapped automatically whenever it is used. You can still
   check if an implicitly unwrapped optional is nil and unwrap it in
   an optional binding. Note: do not use an implicitly unwrapped
   optional when there is a possibility of a variable becoming nil at
   a later point.
   
** Assertions
   
   You write an assertion by calling the global *assert* function. You
   pass the *assert* function an expression that evaluates to *true*
   or *false* and a message that should be displayed if the result of
   the condition is false:
   
   #+BEGIN_SRC swift
     let age = -3
     assert(age >= 0, "A person's age cannot be less than zero")
   #+END_SRC
   
   Note that the assertion message can be omitted if desired:
   
   #+BEGIN_SRC swift
     assert(age >= 0)
   #+END_SRC
   
* Basic Operators
  
** Assignment Operator
   
   The /assignment operator/ (a = b) initializes or update the value of
   a with the value of b. This operator also operates on tuples:
   
   #+BEGIN_SRC swift
     let (x, y) = (1, 2)
   #+END_SRC
   
   The assignment operator (=) does not return a value, to prevent it
   from being mistakenly used when the equal to operator (==) is
   intended.
   
** Arithmetic Operators
   
   Arithmetic operators (+, -, *, /, %, and so forth) detect and
   disallow value overflow.
   
   The addition perator is also supported for /String/ concatenation:
   
   #+BEGIN_SRC swift
    "hello, " + "world" // equals "hello, world"
   #+END_SRC
   
   Swift lets you perform remainder (%) calculations on floating-point
   numbers. Also note that the sign is ignored when using % (that's
   also why it's called /remainder/ instead of /modulo/).
   
   Like C, Swift provides an /increment operator/ (++) and a /decrement
   operator (--) as a shortcut to increase or decrease the value of a
   numeric variable by 1. The ++ and -- symbols can be used as prefix
   operators or as postfix operators:
   
  - If the operator is written /before/ the variable, it increments
    the variable /before/ returning its value.
  - If the operator is written /after/ the variable, it increments the
    variable /after/ returning its value.
    
  Unless you need the specific behavior of i++, it is recommended that
  you use ++i and --i in all cases.
  
  The sign of a numeric value can be toggled using a prefixed -, known
  as the /unary minus operator/:
  
  #+BEGIN_SRC swift
    let three = 3
    let minusThree = -three      // equals -3
    let plusThree = -minusThree  // equals 3
  #+END_SRC
  
** Compound Assignment Operators
   
   Like C, Swift provides /compound assignment operators/ that combine
   assignment (=) with another operation. For example the /addition
   assignment operator (+=).
   
   #+BEGIN_SRC swift
    var a = 1
    a += 2
    // a is now equal to 3
   #+END_SRC
   
** Comparison Operators
   
   Swift supports all standard C /comparison operators/ (==, !=, >, <,
   <=, <=). Also note that Swift provides two /identity operators/ (===
   and !==), which you use to test whether two object references both
   refer to the same object instance.
   
** Range Operators
   
*** Closed Range Operator
    
    The /closed range operator/ (a...b) defines a range that runs from
    a to b, and includes the values a and b. The value of a must not
    be greater than b.
    
    #+BEGIN_SRC swift
      for index in 1...5 {
          println("\(index) times 5 is \(index * 5)")
      }
      // 1 times 5 is 5
      // 2 times 5 is 10
      // 3 times 5 is 15
      // 4 times 5 is 20
      // 5 times 5 is 25

    #+END_SRC
    
*** Half-Open Range Operator
    
    The /half-open range operator/ (a..<b) defines a range that runs
    from a to b, but does not include b (particularly useful for
    zero-based lists). If the value of a is equal to b, then the
    resulting range will be empty.
    
** Logical Operators
   
   Swift supports the three standard logical operators found in
   C-based languages (!, &&, and ||). The AND and OR operators use
   short-circuit evaluation to consider its expressions. The Swift
   logical operators && and || are left-associative, meaning that
   compound expressions with multiple logical operators evaluate the
   leftmost subexpression first.
   
* Strings and Characters
  
** String Literals
   
   #+BEGIN_SRC swift
     let someString = "Some string literal value"
   #+END_SRC
   
   Note that Swift infers a type of *String* for the someString
   constant.
   
** Initializing an Empty String
   
   To create an empty String value as the starting point for building
   a longer string, either assign an empty string literal to a
   variable, or initialize a new String instance with initializer
   syntax:
   
   #+BEGIN_SRC swift
     var emptyString = ""              // empty string literal
     var anotherEmptyString = String() // initializer syntax
   #+END_SRC
   
   Find out whether a String value is empty by checking its Boolean
   isEmpty property:
   
   #+BEGIN_SRC swift
     if emptyString.isEmpty {
         println("Nothing to see here")
     }
   #+END_SRC
   
** String Mutability
   
   You indivate whether a particular String can be modified (or
   /mutated/) by assigning it to a variable (in which ase it can be
   modified), or to a constant (in which case it cannot be modified).
   
** Strings Are Value Types
   
   Swift's String type is a /value type/. If you create a new String
   value, that String value is /copied/ when it is passed to a
   function or method, or when it is assigned to a constant or
   variable.
   
** Working with Characters
   
   Swift's String type represents a collection of *Character* values
   in a specific order. You can access the individual Character values
   in a string by iterating over that string with a for-in loop:
   
   #+BEGIN_SRC swift
     for character in "Dog!" {
         println(character)
     }
   #+END_SRC
   
   Alternativly, create a stand-alone Character constant or variable
   from a single-character string literal by providing a /Character/
   type annotation:
   
   #+BEGIN_SRC swift
     let exclamationMark: Character = "!"
   #+END_SRC
   
   String values can be constructed by passing an array of Character
   values as an argument to its initializer:
   
   #+BEGIN_SRC swift
     let catCharacters: [Character] = ["C", "a", "t", "!"]
     let catString = String(catCharacters)
   #+END_SRC
   
** Concatenating String and Characters
   
   The addition operator (+) can be used to concatenate strings. The
   addition assignment operator (+=) can be used to append a String
   value to an existing String variable. You can append a Character
   value to a String variable with the String type's *append()*
   method:
   
   #+BEGIN_SRC swift
     var welcome = "hello there"
     let exclamationMark: Character = "!"
     welcome.append(exclamationMark)
   #+END_SRC
   
** String Interpolation
   
   #+BEGIN_SRC swift
     let multiplier = 3
     let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
     // message is "3 times 2.5 is 7.5"
   #+END_SRC
   
   Note: the expressions you write inside parentheses within an
   interpolated string cannot contain an unescaped double quote (") or
   backslash(\), and cannot contain a carriage return or line feed.
   
** Counting Characters
   
   To retrieve a count of the *Character* values in a string, call the
   global *count(_:)* function and pass in a string as the function's
   sole parameter:
   
   #+BEGIN_SRC swift
     let animals = "Koala, Snail, Penguin"
     println("animals has \(count(animals)) characters")
     // prints "animals has 21 characters"
   #+END_SRC
   
** Accessing and Modifying a String
   
*** String Indexes
    
    Each *String* value has an associated /index type/,
    *String.Index*, which corresponds to the positions of each
    *Character* it contains. Different characters can require
    different amounts of memory to store; Swift strings cannot be
    indexed by integer values.
    
    Use the *startIndex* property to access the position of the first
    *Character* of a *String*, and the *endIndex* property to access
    the position of the last.
    
    You can use subscript syntax to access the Character at a
    particular String index:
    
    #+BEGIN_SRC swift
      let greeting = "Guten Tag"
      greeting[greeting.startIndex] // G
    #+END_SRC
    
    A *String.Index* value can access its immediately preceding index
    by calling the *predecessor()* method, and its immediately
    succeeding index by calling the *successor()* method. Any index in
    a String can be accessed from any other index by chaining these
    methods together, or by using the global *advance(start:n:)*
    function.
    
    #+BEGIN_SRC swift
      greeting[greeting.startIndex.successor()]   // u
      greeting[greeting.startIndex.predecessor()] // g
      let index = advance(greeting.startIndex, 7)
      greeting[index] // a
    #+END_SRC
    
    Use the global function *indicies(_:)* to create a *Range* of all
    of the indexes used to access individual characters in a string.
    
    #+BEGIN_SRC swift
      for index in indices(greeting) {
          print("\(greeting[index]) ")
      }
      println("\n")
      // prints "G u t e n  T a g"
    #+END_SRC
    
*** Inserting and Removing
    
    To insert a character into a string at a specified index, use the
    *insert(:atIndex:)* method.
    
    #+BEGIN_SRC swift
      var welcome = "hello"
      welcome.insert("!", atIndex: welcome.endIndex)
      println(welcome)
      // prints "hello!"
    #+END_SRC
    
    To insert another string at a specified index, use the
    *splice(_:atIndex:)* method.
    
    #+BEGIN_SRC swift
      welcome.splice(" there", atIndex: welcome.endIndex.predecessor())
      println(welcome)
      // prints "hello there!"
    #+END_SRC
    
    To remove a character from a string at a specified index, use the
    *removeAtIndex(_:)* method.
    
    #+BEGIN_SRC swift
      welcome.removeAtIndex(welcome.endIndex.predecessor()) // !
      println(welcome) // prints "hello there"
    #+END_SRC
    
    To remove a substringat a specified range, use the removeRange(_:)
    method:
    
    #+BEGIN_SRC swift
      let range = advance(welcome.endIndex, -6)..<welcome.endIndex
      welcome.removeRange(range)
      println(welcome)
      // prints "hello"
    #+END_SRC
    
** Comparing Strings
   
   String and character equality is chacked with the "equal to"
   operator (==) and the "not equal to" operator (!=). To check
   whether a string has a particular string prefix or suffix, call the
   string's *hasPrefix(\_:)* and *hasSuffix(\_:)* methods, both of
   which take a single argument of type String and return a Boolean
   value.
   
   #+BEGIN_SRC swift
     let play = "Act 1 Scene 1: Verona, A public place"
     play.hasPrefix("Act 1 ") // evaluates to true
   #+END_SRC
   
** Strings and Arrays
   
   A String can be converted to an Array<Character> like this:
   
   #+BEGIN_SRC swift
     let myArrayOfCharacters = Array(myString)   
   #+END_SRC  
   
* Collection Types
  
  Swift provides three primary /collection types/, known as arrays,
  sets, and dictionaries, for storing collections of values. Arrays
  are ordered collections of values. Sets are unordered collections of
  distinct values. Dictionaries are unordered collections of key-value
  associations. You cannot mix types in collections. Swift's array,
  set, and dictionary types are implemented as /generic collections/.
  
** Mutability of Collections
   
  If you create an array, a set, or a dictionary and assign it to a
  variable, the collection that is created will be
  /mutable/. Conversely, if you assign an array, a set, or a
  dictionary to a constant, that collection is /immutable/, and its
  size and contents cannot be changes. It is good practice to create
  immutable collections in all cases where the collection does not
  need to change. Doing so enables the Swift compiler to optimize the
  performance of the collections you create.
   
** Arrays
   
  An /array/ stored values of the same type in an ordered list. The
  same value can appear in an array multiple times at different
  positions.

*** Array Type Shorthand Syntax

  The type of a Swift array is written in full as *Array<SomeType>*,
  where *SomeType* is the type of values the array is allowed to
  store. You can also write the type of an array in shorthand form as
  *[SomeType]*. Although the two forms are functionally identical,
  the shorthand form is preferred and is used throughout this guide
  when referring to the type of an array.

*** Creating and Initializing an Array

  You can create an empty array of a certain type using initializer
  syntax:

  #+BEGIN_SRC swift
    var someInts = [Int]()
    println("someInts is of type [Int] with \(someInts.count) items.")
    // prints "someInts is of type [Int] with 0 items."
  #+END_SRC

  Alternatively, if the context already provides type information,
  such as a function argument or an already types variable or
  constant, you can create an empty array with an empty array literal,
  which is written as [].

  #+BEGIN_SRC swift
    someInts.append(3)
    // someInts now contains 1 value of type Int
    someInts = []
    // someInts is now an empty array, but it still of type [Int]
  #+END_SRC
  
  Swift's Array type also provides an initializer for creating an
  array of a certain size with all of its values set to a provided
  default value. You pass this initializer the number of items to be
  added to the new array (called *count*) ad a default value of the
  appropriate type (called *repeatedValue*):

  #+BEGIN_SRC swift
    var threeDoubles = [Double](count: 3, repeatedValue: 0.0)
    // [0.0, 0.0, 0.0]
  #+END_SRC
  
  You can create a new array by adding toether two existing arrays
  with compatible types with teh addition operator (+). The new
  array's type is inferred from the type of the two arrays you add
  together:

  #+BEGIN_SRC swift
    var anotherThreeDoubles = [Double](count: 3, repeatedValue: 2.5)
    // [2.5, 2.5, 2.5]
    var sixDoubles = threeDoubles + anotherThreeDoubles
    // [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
  #+END_SRC
  
*** Array Literals

  /Array literals/ is written as a list of values, separated by
  commas, surrounded by a pair of square brackets.

  #+BEGIN_SRC swift
    var shoppingList: [String] = ["Eggs", "Milk"]
    // shoppingList has been initialized with two initial items
  #+END_SRC

  The *shoppingList* variable is declared as "an array of string
  values", written as *[String]*. Because this particular array has
  specified a value type of String, it is allowed to store String
  values only.

  Thanks to Swift's type inference, you don't have to write the type
  of the array if you're initializing it with an array literal
  containing values of the same type. The initialization of
  *shoppingList* could have been written in a shorter form instead:

  #+BEGIN_SRC swift
    var shoppingList = ["Eggs", "Milk"]
  #+END_SRC
  
*** Accessing and Modifying an Array

  You access and modify an array through its methods and properties,
  or by using subscript syntax.

  | Name                | Type     | Description                       |
  |---------------------+----------+-----------------------------------|
  | count               | property | Number of items                   |
  | isEmpty             | property | Check if count is 0               |
  | append(_:)          | method   | Add new item to end               |
  | +=                  | operator | Append arrays                     |
  | [num]               | operator | /Subscript syntax/ for get/set    |
  | [num...num]         | operator | Subscript syntax with range       |
  | insert(\_:atIndex:) | method   | Insert item at specified index    |
  | removeAtIndex(\_:)  | method   | Removes and returns item at index |
  | removeLast()        | method   | Removes and returns last item     |
  
*** Iterating Over an Array

  You can iterate over the entire set of values in an array with the
  *for-in* loop:

  #+BEGIN_SRC swift
    for item in shoppingList {
        println(item)
    }
  #+END_SRC

  If you need the index of each item as well as its value, use the
  global *enumerate* function to iterate over the array instead. The
  *enumerate* function returns a typle for each item in the array
  composed of the index and the value for that item. You can decompose
  the typle into temporary constants or variables as part of the
  iteration:

  #+BEGIN_SRC swift
    for (index, value) in enumerate(shoppingList) {
        println("Item \(index + 1): \(value)")
    }
  #+END_SRC

*** Other Tips

  There is also a function called *last* in Array that returns an
  *Optional* (i.e. it will return nil if, and only if, the Array
  isEmpty).

** Sets

   The type of a Swift set is written as *Set<SomeType>*, where
   *SomeType* is the type that the set is allowed to store. Unlike
   arrays, sets do not have an equivalent shorthand form.

   #+BEGIN_SRC swift
     var letters = Set<Character>()
   #+END_SRC
   
   Alternatively, if the context already provides type information,
   such as a function argument or an already typed variable or
   constant, you can create an empty set with an empty array literal:

   #+BEGIN_SRC swift
     letters.insert("a")
     letters = []
   #+END_SRC

   You can also initialize a set with an array literal, as a shorthand
   way to write one or more values as a set collection.

   #+BEGIN_SRC swift
     var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
   #+END_SRC

   Because of Swift's type inference, you don't have to write the type
   of the set if you're initializing it with an array literal
   containing values of the same type. the initialization of
   /favoriteGenres/ could have been written in a shorter form instead:

   #+BEGIN_SRC swift
     var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
   #+END_SRC

*** Accessing and Modifying a Set

  | Name         | Type     | Description                          |
  |--------------+----------+--------------------------------------|
  | count        | property | find number of items in a set        |
  | isEmpty      | property | check if count is equal to 0         |
  | insert(\_:)  | method   | add a new item into a set            |
  | remove(\_:)  | method   | remove an item from a set            |
  | removeAll()  | method   | remove all items in a set            |
  | contains(_:) | method   | check whether a set contains an item |

*** Iterating Over a Set

  You can iterate over the values in a set with a *for-in* loop.

  #+BEGIN_SRC swift
    for genre in favoriteGenres {
        println("\(value)")
    }
  #+END_SRC
  
  Swift's *Set* type does not have a defined ordering. To iterate over
  the values of a set in a specific order, use the global *sorted*
  function, which returns an ordered collection of the provided
  sequence.

  #+BEGIN_SRC swift
    -> for genre in sorted(favoriteGenres) {
           println("\(genre)")
       }
  #+END_SRC

*** Performing Set Operations

**** Constructing Sets

  | Operation        | Result                                                   |
  |------------------+----------------------------------------------------------|
  | union(\_:)       | create a new set will all the values in both sets        |
  | subtract(\_:)    | create a new set with values not in the specified set    |
  | intersect(\_:)   | create a new set with only the values in common          |
  | exclusiveOr(\_:) | create a new set with values in either set, but not both |

**** Comparing Sets

  Use the "is equal" operator (==) to determine whether two sets
  contain all of the same values. *isSubsetOf(\_:*,
  *isSupersetOf(\_:)*, *isStrictSubsetOf(\_:)*,
  *isStrictSupersetOf(\_:)*, and *isDisjointWith(\_:)* can be used to
  compare sets.

**** Hash Values for Set Types

  A type must be /hashable/ in order to be stored in a set - that is,
  the type must provide a way to compute a /hash value/ for itself. A
  hash value is an Int value that is the same for all objects that
  compare equal, such that if a == b, if follows that a.hashValue =
  b.hashValue.

  All of Swift's basic types (such as String, Int, Double, and Bool)
  are hashable by default, and can be used as set values types or
  dictionary key types. Enumeration member values without assoc iated
  values are also hashable by default.

  You can use your own custom types as set value types or dictionary
  key types by making them conform to the *Hashable* protocol from
  Swift's standard library.

* Control Flow

** For-in Loop

   The *for-in* loop performs a set of statements for each item in a
   sequence. The *for* loop performs a set of statements until a
   specific condition is met, typically by incrementing a counter each
   time the loop ends.

   #+BEGIN_SRC swift
     for index in 1...5 {
         println("\(index) times 5 is \(index * 5)")
     }
   #+END_SRC

   In the example above, *index* is a constant. If you don't need each
   value from a sequence, you can ignore the values by using an
   underscore in place of a variable name:

   #+BEGIN_SRC swift
     let base = 3
     let power = 10
     var answer = 1
     for _ in 1...power {
         answer *= base
     }
     println("\(base) to the power of \(power) is \(answer)")
   #+END_SRC

   You can also use a *for-in* loop with an array to iterate over its
   items:

   #+BEGIN_SRC swift
     let names = ["Anna", "Alex", "Brian", "Jack"]
     for name in names {
         println("Hello, \(name)!")
     }
   #+END_SRC

   You can also iterate over a dictionary to access its key-value
   pairs. Each item in the dictionay is returned as a (key, value)
   tuple when the dictionary is iterated, and you can decompose the
   (key, value) typle's members as explicitly named constants for use
   within the body of the *for-in* loop:

   #+BEGIN_SRC swift
     let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
     for (animalName, legCount) in numberOfLegs {
         println("\(animalName)s have \(legCount) legs")
     }
   #+END_SRC

** For Loop

    Swift supports traditional C-style *for* loops with a condition
    and an incrementer:

    #+BEGIN_SRC swift
      for var index = 0: index < 3; ++index {
          println("index is \(index)")
      }
    #+END_SRC

    Constants and variables declared within the initialization
    expression (such as var index = 0) are only valid within the scope
    of the *for* loop itself. To retrieve the final value of *index*
    after the loop ends, you must declare *index* before the loop's
    scope begins:

    #+BEGIN_SRC swift
      var index: Int
      for index = 0; index < 3; ++index {
          println("index is \(index)")
      }
    #+END_SRC

** While Loop

   Swift provides two kinds of *while* loop. *while* evaluates its
   condition at the start of each pass through the loop. *do-while*
   evaluates its condition at the end of each pass through the loop.

   #+BEGIN_SRC swift
     while condition {
         statements
     }

     do {
         statements
     } while condition
   #+END_SRC

** Conditional Statements

*** If

    In its simplest form, the *if* statement has a single *if*
    condition. The *if* statement can provide an alternative set of
    statements known as an /else clause/. These statements are
    indicated by the *else* keyword.

    #+BEGIN_SRC swift
      var temperatureInFahrenheit = 30
      if temperatureInFahrenheit <= 32 {
          println("It's very cold. Consider wearing a scarf.")
      }

      temperatureInFahrenheit = 40
      if temperatureInFahrenheit <= 32 {
          println ("It's very cold. Consider wearing a scarf.")
      } else {
          println ("It's not that cold. Wear a t-shirt.")
      }
    #+END_SRC

    You can also chain multiple *if* statements together, to consider
    additional clauses.

*** Switch

    A *switch* statement considers a value and compares it against
    several possible matching patterns. It then executes an
    appropriate block of code, based on the first pattern that matches
    successfully.

    #+BEGIN_SRC swift
      switch some value to consider {
      case value 1:
          respond to value 1
      case value 2, value 3:
          respond to value 2 or 3
      default:
          otherwise, do something else
      }
    #+END_SRC

    Every *switch* statement must be /exhaustive/. That is, every
    possible value of the type being considered must be matched by one
    of the *switch* cases.

    In contrast with *switch* statements in C and Objective-C,
    *switch* statements in Swift do not fall through the bottom of
    each case and into the next one by default. Instead, the entire
    *switch* statement finishes its execution as soon as the first
    matching *switch* case is completed, without requiring an explicit
    *break* statement.

**** Interval Matching

     Values in *switch* cases can be checked for their inclusion in an
     interval. This example uses number intervals to provide a natural
     language for numbers of any size.

     #+BEGIN_SRC swift
       let count = 3_000_000_000_000
       let countedThings = "stars in the Milky Way"
       var naturalCount: String
       switch count {
       case 0:
           naturalCount = "no"
       case 1...3:
           naturalCount = "a few"
       case 4...9:
           naturalCount = "several"
       case 10...99:
           naturalCount = "tens of"
       case 100...999:
           naturalCount = "hundreds of"
       case 1000...999_999:
           naturalCount = "thousands of"
       default:
           naturalCount = "millions and millions of"
       }
     #+END_SRC
     
     Both the closed range operator (...) and half-open range operator
     (..<) functions are overloaded to return either an IntervalType
     or Range. An interval can determine whether it contains a
     particular element, such as when matching a *switch* statement
     *case*. A range is a collection of consecutive values, which can
     be iterated on in a *for-in* statement.

** Control Transfer Statements

*** Continue

    The *continue* statement tells a loop to stop what it is doing and
    start again at the beginning of the next iteration through the loop.

*** Break

    The *break* statement ends execution of an entire control flow
    statement immediately. The *break* statement can be used inside a
    switch statement or loop statement when you want to terminate the
    execution of the *switch* or loop statement earlier than would
    otherwise be the case.

    Because Swift's *switch* statment is exhaustive and does not allow
    empty cases, it is sometimes necessary to deliberately match and
    ignore a case in order to make your interntions explicit. You do
    this by writing the *break* statement as the entire body of the
    case you want to ignore.

    #+BEGIN_SRC swift
      let numberSymbol: Character = "三"
      var possibleIntegerValue: Int?
      switch numberSymbol {
      case "1", "١", "一", "๑":
          possibleIntegerValue = 1
      case "2", "٢", "二", "๒":
          possibleIntegerValue = 2
      case "3", "٣", "三", "๓":
          possibleIntegerValue = 3
      case "4", "٤", "四", "๔":
          possibleIntegerValue = 4
      default:
          break
      }
      if let integerValue = possibleIntegerValue {
          println("The integer value of \(numberSymbol) is \(integerValue).")
      } else {
          println("An integer value could not be found for \(numberSymbol).")
      }
    #+END_SRC

*** Fallthrough

    Switch statements in Swift do not fall through the bottom of each
    case and into the next one. If you really need C-style fallthrough
    behavior, you can opt in to this behavior on a case-by-case basis
    with the *fallthrough* keyword.
