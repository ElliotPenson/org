#+TITLE: The Algorithm Design Manual Exercises
#+AUTHOR: Elliot Penson

* Chapter 1: Introduction

** 1-1

   a = -1 and b = -1 produces -2. This is less than min(a, b).

** 1-3

   Roads have different speed limits! We just need a long road that allows fast
   travel.

** 1-5

   A. S = {1, 2, 3}, T = 5
   B. S = {1, 2, 3}, T = 5
   C. S = {1, 3, 5}, T = 6

** 1-7

   Suppose that ~c = 2~. We know that ~multiply(x, 0)~ is always ~0~. Based on
   the pseudocode, ~multiply(x, y)~ is equal to
   - ~multiply(2 * x, floor(y / 2)) + x * (y mod 2)~
   - ~(2 * x) * floor(y / 2) + x * (y mod 2)~
   - ~x * (2floor(y / 2) + y mod 2)~
   - ~x * y~
   When we assume that ~multiply(2 * x, floor(y / 2)) = 2x * floor(y / 2)~.

** 1-9

   *Base Case*: len(A) = 1. This list is sorted.

   *Inductive Case*: Assume that bubblesort([1...n]) is sorts the list. To prove
   that bubblesort([1...n + 1]) also sorts the list, we just need to show that
   the main loop will correctly place the last element in the list. This
   naturally follows from the "bubbling" to the correct position.

   QED.

** 1-11

   *Base Case*: Suppose ~n = 1~.
   - $\sum_{i=1}^{n} i^2 = \frac{n(n + 1)(2n + 1)}{6}$
   - $(1)^2 = \frac{(1)((1) + 1)(2(1) + 1)}{6}$
   - $1 = \frac{(1)(2)(3)}{6}$
   - $1 = 1$

   *Inductive Case*: Assume that $\sum_{i=1}^{n} i^2 = \frac{n(n + 1)(2n +
   1)}{6}$. Now let's prove that ~n + 1~ also works. $\sum_{i=1}^{n + 1} i^2 =
   \sum_{i=1}^{n} i^2 + (n + 1)^2$. We can show mathematically that
   $\frac{n(n + 1)(2n + 1)}{6} + (n + 1)^2 = \frac{(n + 1)((n + 1) +
   1)(2(n + 1) + 1)}{6}$.

   QED.

** 1-19

   The average number of pages in my books is around 300. I have 18 small
   shelves of books. Each shelf has around 15 books. I estimate that all the
   books I own have 300 * 18 * 15 = 81,000 pages. This is far less than one
   million pages!

   My school library has three floors. Each floor has around 50 rows of
   books. Each row has around 30 large shelves of books. Each shelf has around
   50 books. I estimate that the number of pages in my school library is 300 *
   3 * 50 * 30 * 50 = 67,500,000 pages.

* Chapter 2: Algorithm Analysis

** 2-1

   The worst case is $O(n^3)$.

** 2-3

   The worst case is $O(n^4)$.

** 2-5

   1. $2n$ multiplications in the worst case. $n$ additions.
   2. $2n$ multiplications on average.

** 2-7

   1. Yes! $2^{n + 1} = 2*2^n$ and we can drop the constant.
   2. No!

** 2-9

   1. $g(n) = O(f(n))$
   2. $f(n) = O(g(n))$
   3. $f(n) = O(g(n))$
   4. $g(n) = O(f(n))$
   5. $g(n) = O(f(n))$
   6. $f(n) = O(g(n))$

** 2-11

   For all $n > 3$, $n^2 <= 2^n$ with a constant of 1. Therefore, $n^2 =
   O(2^n)$.

** 2-12

   1. $1$
   2. $2$
   3. $2$

* Chapter 3: Data Structures

** 3-1

   #+BEGIN_SRC python
     def is_balanced(expression):
         stack = []
         for char in expression:
             if char == '(':
                 stack.append(char)
             else:  # char == ')'
                 if not stack:
                     return False
                 stack.pop()
         return not stack
   #+END_SRC

** 3-3

   1. Let's say that we have an array of size 10 that contains 6
      elements. Delete two, insert two, repeat.
   2. 1/3 instead of half.

** 3-5

   1. 1/4
   2. 1/2

** 3-7

   We maintain the current max and min. Insert should compare the given value to
   the max and the min (and potentially substitute). Delete should check and see
   if the value to be deleted is the max/min, if it is set max/min to the
   predecessor/successor.

** 3-9

   Find and delete the smallest key in $S_2$ (this takes $O(h)$). Set this key
   as a new root. The left subtree should be $S_1$, the right subtree should be
   $S_2$.

** 3-11

   Precalculate the answers! Store in a dictionary: key = i + j, value =
   $min(x_i...x_j)$.

** 3-21

   #+BEGIN_SRC python
     def equal(tree1, tree2):
         if not tree1:
             return not tree2
         if not tree2:
             return not tree1
         return (tree1.key == tree2.key and
                 equal(tree1.left, tree2.left) and
                 equal(tree1.right, tree2.right))
   #+END_SRC

** 3-23

   #+BEGIN_SRC python
     def reverse(linked_list):
         if not linked_list or not linked_list.next:
             return linked_list
         rest = reverse(linked_list.next)
         linked_list.next.next = linked_list
         linked_list.next = None
         return rest
   #+END_SRC

** 3-25

   Check Counter(magazine) against search string.

** 3-27

   With extra space:

   #+BEGIN_SRC python
     def has_loop(linked_list, seen=set()):
         if not linked_list:
             return False
         elif linked_list.key in seen:
             return True
         else:
             seen.add(linked_list.key)
             return has_loop(linked_list.next, seen)
   #+END_SRC

** 3-29

   We can do this in linear time with some extra space. Maintain a dictionary
   from word pair to count. Traverse the word pair, finding the counts. Then
   look for the pair with the highest count.
