#+TITLE: The Algorithm Design Manual
#+AUTHOR: Elliot Penson

This document houses my notes from /The Algorithm Design Manual/ by Steven
S. Skiena. Also see [[file:algorithm-design-manual-exercises.org][my answers to odd exercises]].

* Chapter 1: Introduction

  A *problem* is specified by describing the complete set of *instances* it must
  work on and of its output after running on one of these instances. For
  example, an instance of the sorting problem might be ~[1, 4, 3]~. An
  *algorithm* is a procedure that takes any of the possible input instances and
  transforms it to the desired output. There are many different algorithms that
  solve the problem of sorting.

  We seek algorithms that are /correct/, /efficient/, and /easy to
  implement/. These goals may not be simultaneously achievable!

  There is a fundamental difference between algorithms, which always produce a
  correct result, and *heuristics*, which may usually do a good job but without
  providing any guarantee. For example, the nearest-neighbor heuristic can be
  applied to the /traveling salesman problem (TSP)/, but sometimes this
  heuristic doesn't even come close to finding the shortest possible tour.

** Correctness

   Reasonable-looking algorithms can easily be incorrect. Algorithm correctness
   is a property that must be carefully demonstrated. The primary tool to
   distinguish correct algorithms from incorrect ones is a *proof*. A proof has
   four main parts.

   1. Clear, precise statement of what you are trying to prove.
   2. Set of assumptions.
   3. Chain of reasoning that takes you from the assumptions to the statement
      you are trying to prove.
   4. Little, black square or /QED/.

   To reason about an algorithm, you need a careful description of the sequence
   of steps to be performed. The three most common forms of algorithmic notation
   are English, pseudocode, or a real programming language. These methods have
   natural tradeoffs between expression and precision.

*** Incorrectness

   The best way to prove that an algorithm is /incorrect/ is to produce an
   instance in which it yields an incorrect answer. Such instances are called
   *counter-examples*. Good counter-examples are verifiable and simple. Many
   tricks exist for finding counter-examples.

   - /Think small/: small examples are easier to reason about.
   - /Think exhaustively/: consider different types of examples.
   - /Go for a tie/: try similar values in the input collection.
   - /Seek extremes/: e.g. use values that are far apart or close together.

*** Induction

    *Mathematical induction* is a common choice for proving correctness. If
    you're familiar with recursion, you're familiar with induction; recursion
    /is/ induction. In both, we have general and boundary conditions. The
    general condition breaks the problem into smaller and smaller pieces and the
    boundary condition terminates the recursion. Suppose that you are trying to
    prove that a statement holds true for all natural numbers (all
    $n$). Induction would usually take the form:

    1. Show that the statement holds for the base case (usually $P(0)$ or
       $P(1)$).
    2. Assume that $P(k)$ is true.
    3. Prove that the statement also holds for $P(k + 1)$.

*** Summations

    Summation formula are concise expressions describing the addition of an
    arbitrarily large set of numbers.

    \begin{equation}
    \sum_{i=1}^{n} f(i) = f(1) + f(2) + ... + f(n)
    \end{equation}

    There are simple closed forms for summations of many algebraic functions.

    \begin{equation}
    \sum_{i=1}^{n} 1 = n
    \end{equation}

    \begin{equation}
    \sum_{i=1}^{n} i = \frac{n(n + 1)}{2}
    \end{equation}

** Program Modeling

   Modeling is the art of formulating your application in terms of precisely
   described, well-understood problems. Proper modeling can eliminate the need
   to design or even implement algorithms, by relating your application to what
   has been done before.

   Real-world applications involve real-world objects. Most algorithms, however,
   are designed to work on rigorously defined /abstract/ structures. To exploit
   the algorithms literature, you must learn to describe your problem
   abstractly, in terms of procedures on fundamental structures.

   - *Permutations* are arrangements, or orderings of items. Usually the object
     in question if your problem seeks an "arrangement," "tour," "ordering," or
     "sequence."
   - *Subsets* are selects from a set of items. Usually the object in question
     if your problem seeks a "cluster," "collection," "committee," "group,"
     "packaging," or "selection."
   - *Trees* are hierarchical relationships between items. Usually the object in
     question whenever your problem seeks a "hierarchy," "dominance
     relationship," "ancestor/descendant relationship," or "taxonomy."
   - *Graphs* represent relationships between arbitrary pairs of
     objects. Usually the object in question whenever you seek a "network,"
     "circuit," "web," or "relationship."
   - *Points* represent locations in some geometric space. Usually the object in
     question whenever your problems work on "sites," "positions," "date
     records," or "locations."
   - *Polygons* represent regions in some geometric spaces. Usually the object
     in question whenever you are working on "shapes," "regions,"
     "configurations," or "boundaries."
   - *Strings* represent sequences of characters or patterns. Usually the object
     in question whenever you are dealing with "text," "characters," "patterns,"
     or "labels."

   Learn to think recursively. Recursive structures occur everywhere in the
   algorithmic world. Each of the abstract structures described above can be
   thought about recursively; they are big things made of smaller things of the
   same type. Each structure has operations (like /delete/) that produce new
   versions of the same type.
